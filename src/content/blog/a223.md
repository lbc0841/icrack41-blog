---
title: "a223. 10298 - Power Strings"
description: ""
date: 2025-05-16
tags: ["cpp"]
---

## 解法一、KMP

### 🔹 最長公共前後綴

開一個大小為 `s.size()` 的矩陣 `kmp[]`<br>
其中 `kmp[i]` 紀錄的是 `s[0] ~ s[i]` 的 **最長起始位置不同的前後綴字串** 的長度

初始化 `kmp[0] = 0` (`s[0]` 跟 `s[0]` 起始位置相同)<br>
如果 `s[i] = s[kmp[i-1]]` 則 `kmp[i] = kmp[i-1] + 1`<br>
否則 `kmp[i] = 0`

最短重複子字串長度 = `s.size()` - `kmp.back()`<br>
最大重複次數 = `s.size()` / `重複子字串長度`

驗證 `s.size()` / `重複子字串長度` 能整除<br>
否則最大重複次數 = 1

### 🔸 e.g. `s = "AAABAAAB"`

<font color="#00bb00">綠字</font> 表示 **最長起始位置不同的前後綴字串**<br>
<font color="#ff0000">紅字</font> 代表匹配錯誤 (`kmp[i] = 0`)<br>
底下的數字是字串長度 (`kmp[i]`)

| A<br>A | A<br>A | A<br>A | B<br>B | A<br>A | A<br>A | A<br>A | B<br>B |
|---|---|---|---|---|---|---|---|
| 0 |   |   |   |   |   |   |   |

| <font color="#00bb00">A</font><br>A | A<br><font color="#00bb00">A</font> | A<br>A | B<br>B | A<br>A | A<br>A | A<br>A | B<br>B |
|---|---|---|---|---|---|---|---|
| 0 | 1 |   |   |   |   |   |   |

| <font color="#00bb00">A</font><br>A | <font color="#00bb00">A</font><br><font color="#00bb00">A</font> | A<br><font color="#00bb00">A</font> | B<br>B | A<br>A | A<br>A | A<br>A | B<br>B |
|---|---|---|---|---|---|---|---|
| 0 | 1 | 2 |   |   |   |   |   |

| <font color="#00bb00">A</font><br>A | <font color="#00bb00">A</font><br><font color="#00bb00">A</font> | <font color="#ff0000">A</font><br><font color="#00bb00">A</font> | B<br><font color="#ff0000">B</font> | A<br>A | A<br>A | A<br>A | B<br>B |
|---|---|---|---|---|---|---|---|
| 0 | 1 | 2 | 0 |   |   |   |   |

| <font color="#00bb00">A</font><br>A | A<br>A | A<br>A | B<br>B | A<br><font color="#00bb00">A</font> | A<br>A | A<br>A | B<br>B |
|---|---|---|---|---|---|---|---|
| 0 | 1 | 2 | 0 | 1 |   |   |   |

| <font color="#00bb00">A</font><br>A | <font color="#00bb00">A</font><br>A | A<br>A | B<br>B | A<br><font color="#00bb00">A</font> | A<br><font color="#00bb00">A</font> | A<br>A | B<br>B |
|---|---|---|---|---|---|---|---|
| 0 | 1 | 2 | 0 | 1 | 2 |   |   |

| <font color="#00bb00">A</font><br>A | <font color="#00bb00">A</font><br>A | <font color="#00bb00">A</font><br>A | B<br>B | A<br><font color="#00bb00">A</font> | A<br><font color="#00bb00">A</font> | A<br><font color="#00bb00">A</font> | B<br>B |
|---|---|---|---|---|---|---|---|
| 0 | 1 | 2 | 0 | 1 | 2 | 3 |   |

| <font color="#00bb00">A</font><br>A | <font color="#00bb00">A</font><br>A | <font color="#00bb00">A</font><br>A | <font color="#00bb00">B</font><br>B | A<br><font color="#00bb00">A</font> | A<br><font color="#00bb00">A</font> | A<br><font color="#00bb00">A</font> | B<br><font color="#00bb00">B</font> |
|---|---|---|---|---|---|---|---|
| 0 | 1 | 2 | 0 | 1 | 2 | 3 | 4 |

因此 `AAABAAAB` 最短重複子字串長度為<br>
`s.size()` - `kmp.back()` = 4

重複次數為<br>
`s.size()` / `重複子字串長度` = 2

### ✅ 完整代碼

評分結果(參考) ： **<font color="#00bb00">AC</font> (0.1s, 9.8MB)**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    while (cin >> s && s != ".") {
        int size = s.size();

        vector<int> kmp(size);
        for(int i=1; i<size; i++){
            int j = kmp[i-1];
            while(j>0 && s[i]!=s[j]){
                j = kmp[j - 1];
            }
            if(s[i] == s[j]){
                j++;
            }
            kmp[i] = j;
        }
    
        int p = size - kmp.back(); // period

        if(size%p == 0){
            cout << size/p << "\n";
        }
        else{
            cout << 1 << "\n";
        }
    }

    return 0;
}
```

***

## 解法二、窮舉

### 🔹 窮舉因數

窮舉重複字串可能的長度<br>
只有長度是 `s.size()` 的因數的 重複字串長度 才能讓 字串重複次數 是整數<br>
然後對每個位置判斷是否相同

### ✅ 完整代碼

評分結果(參考) ： **<font color="#00bb00">AC</font> (44ms, 2.2MB)**

```cpp
#include <bits/stdc++.h>
using namespace std;

string s;

bool check(int size){
    for(int i=size; i<s.size(); i++){
        if(s[i] != s[i-size]) return false;
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> s && s != ".") {
        int ans = 1;
        int size = s.size();

        for(int i=1; i<=size/2; i++){
            if(size%i != 0) continue;
            
            if(check(i)){
                ans = size/i;
                break;
            }
        }
    
        cout << ans << "\n";
    }

    return 0;
}
```
