---
title: "q082. 小明的次方和(簡單版)"
description: ""
date: 2025-05-16
tags: ["cpp"]
---

## 解法一

### 🔹 大數計算

「**凡是奇數次方和，都是有公式的，而偶數次方和就沒有**」<br>
也就是 $a^{n} + b^{n}$，當 $n$ 是偶數時可以使用某種公式計算

這裡不用搞懂所謂的「公式」到底是甚麼<br>
題目求的是 **能不能** 使用公式計算<br>
其實就是求 n 是不是偶數<br>
而第二行 兩個數的n次方和 直接算出來即可

數字很大，不能直接計算乘法<br>
參考 <font color="#51a2ff">[a021. 大數運算](/icrack41-blog/blog/a021)</font>

然後以快速冪計算次方 : <br>
如果要算 $a^{n}$，可以使用遞迴避免重複的計算<br>

1. 當 $n$ 是偶數，拆成 $a^{n/2} * a^{n/2}$ (這樣只需要計算一遍 $a^{n/2}$)
2. 當 $n$ 是奇數，拆成 $a * a^{n-1}$ (n-1 一定是偶數，又可以回到第 1 點)
3. 當 $n = 1$，迴傳 $a$

### ✅ 完整代碼

評分結果(參考) ： **<font color="#00bb00">AC</font> (2ms, 336KB)**

```cpp
#include <bits/stdc++.h>
using namespace std;

string bigAdd(string a, string b){
    int size = max(a.size(), b.size());
    string ans;
    
    int x = 0;
    for(int i=0; i<size; i++){
        int ai = i<a.size() ? a[a.size()-i-1]-'0' : 0;
        int bi = i<b.size() ? b[b.size()-i-1]-'0' : 0;
        int res = ai + bi + x;
        
        ans += (res%10 + '0');
        x = res/10;
    }
    if(x > 0) ans += (x + '0');
    
    while(ans.size()>1 && ans.back()=='0') ans.pop_back();
    reverse(ans.begin(), ans.end());
    return ans;
}

string bigMul(string a, string b){
    int size = a.size() + b.size();
    vector<int> res(size+1, 0);
    string ans;

    for(int i=0; i<a.size(); i++){
        for(int j=0; j<b.size(); j++){
            res[i+j] += (a[a.size()-i-1]-'0')*(b[b.size()-j-1]-'0');
        }
    }

    for(int i=0; i<size; i++){
        ans += res[i]%10 + '0';
        res[i+1] += res[i]/10;
    }

    while(ans.size()>1 && ans.back()=='0') ans.pop_back();
    reverse(ans.begin(), ans.end());
    return ans;
}

string bigPow(string a, int n){
    if(n == 1) return a;
     
    if(n & 1){
        return bigMul(a, bigPow(a, n-1));
    }
    else{
        string temp = bigPow(a, n/2);
        return bigMul(temp, temp);
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    string a, b;
    cin >> n >> a >> b;
    
    if(n & 1){
        cout << "能\n";
        cout << bigAdd(bigPow(a, n), bigPow(b, n));
    }
    else cout << "不能";
    
    return 0;
}
```

***

## Python 解

因為 Python 數字沒有大小限制<br>
真的太好做大數的計算了

### ✅ 完整代碼

評分結果(參考) ： **<font color="#00bb00">AC</font> (18ms, 3.3MB)**

```py
n = int(input())
a, b = list(map(int, input().split()))

if n%2 == 0:
    print("不能")
else:
    print(f"能\n{(pow(a,n)+pow(b,n))}")
```
