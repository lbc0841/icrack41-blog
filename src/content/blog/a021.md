---
title: "a021. 大數運算"
description: ""
date: 2025-05-16
tags: ["cpp"]
--- 

## 解法一、模擬

用字串模擬加減乘除過程

### 🔹 ALB (a < b ?)

判斷 a 是否 < b，這個函數將用於輔助之後的減法與除法<br>
如果字串長度不同則用長度 (數字位數) 判斷大小<br>
否則根據字典續判斷

### 🔹 Big Add (+)

模擬加法直式過程<br>
由低位往高位處理 (在字串 `s` 中，最低位是 `s[s.size()-1]`)<br>
用 `x` 紀錄進位

### 🔹 Big Sub (-)

模擬減法直式過程<br>
由低位往高位處理 (在字串 `s` 中，最低位是 `s[s.size()-1]`)<br>
用 `x` 紀錄借位

### 🔹 Big Mul (*)

模擬乘法直式過程<br>

### 🔹 Big Div (/)

模擬除法直式過程<br>

### ✅ 完整代碼

評分結果(參考) ： **<font color="#00bb00">AC</font> (2ms, 344KB)**

```cpp
#include <bits/stdc++.h>
using namespace std;

// a < b ?
bool alb(string a, string b){
    if(a.size() != b.size()) return a.size() < b.size();
    return a < b;
}

// +
string bigAdd(string a, string b){
    int size = max(a.size(), b.size());
    string ans;
    
    int x = 0;
    for(int i=0; i<size; i++){
        int ai = i<a.size() ? a[a.size()-i-1]-'0' : 0;
        int bi = i<b.size() ? b[b.size()-i-1]-'0' : 0;
        int res = ai + bi + x;
        
        ans += (res%10 + '0');
        x = res/10;
    }
    if(x > 0) ans += (x + '0');
    
    while(ans.size()>1 && ans.back()=='0') ans.pop_back();
    reverse(ans.begin(), ans.end());
    return ans;
}

// -
string bigSub(string a, string b){
    int size = max(a.size(), b.size());
    string ans;
    
    bool neg = alb(a, b);
    if(neg) swap(a, b);
    
    int x = 0;
    for(int i=0; i<size; i++){
        int ai = i<a.size() ? a[a.size()-i-1]-'0' : 0;
        int bi = i<b.size() ? b[b.size()-i-1]-'0' : 0;
        int res = ai - bi - x;
        
        if(res < 0){
            ans += (res+10 + '0');
            x = 1;
        }
        else{
            ans += (res + '0');
            x = 0;
        }
    }
    
    while(ans.size()>1 && ans.back()=='0') ans.pop_back();
    if(neg) ans += '-';
    reverse(ans.begin(), ans.end());
    return ans;
}

// *
string bigMul(string a, string b){
    int size = a.size() + b.size();
    vector<int> res(size+1, 0);
    string ans;

    for(int i=0; i<a.size(); i++){
        for(int j=0; j<b.size(); j++){
            res[i+j] += (a[a.size()-i-1]-'0')*(b[b.size()-j-1]-'0');
        }
    }

    for(int i=0; i<size; i++){
        ans += res[i]%10 + '0';
        res[i+1] += res[i]/10;
    }

    while(ans.size()>1 && ans.back()=='0') ans.pop_back();
    reverse(ans.begin(), ans.end());
    return ans;
}

// /
string bigDiv(string a, string b){
    string ans, cur;
    bool ignore0 = true;
    
    for(int i=0; i<a.size(); i++){
        cur.push_back(a[i]);
        int res = 0;
        while(!alb(cur, b)){
            cur = bigSub(cur, b);
            res++;
        }
        
        if(res!=0 || !ignore0){
            ans.push_back(res+'0');
            ignore0 = false;
        }
        
        if(cur == "0") cur = "";
    }

    if(ans == "") return "0";
    return ans;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string a, b;
    char op;
    cin >> a >> op >> b;
        
    if     (op == '+') cout << bigAdd(a, b);
    else if(op == '-') cout << bigSub(a, b);        
    else if(op == '*') cout << bigMul(a, b);
    else if(op == '/') cout << bigDiv(a, b);

    return 0;
}
```
